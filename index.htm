<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Escape Room 3D - Noir Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; touch-action: none; }
        canvas { display: block; filter: grayscale(100%) contrast(120%); }

        /* Interface Principal */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        /* Joysticks */
        .joystick-container {
            position: absolute;
            bottom: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            z-index: 150;
            display: none;
            touch-action: none;
        }
        #left-joystick { left: 40px; }
        #right-joystick { right: 40px; }
        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Botão de Pular */
        #jump-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 160;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            user-select: none;
            cursor: pointer;
        }

        /* Botão de Engrenagem */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 100;
            fill: white;
            opacity: 0.7;
        }

        /* Telas de Menu */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
        }

        .menu-card {
            background: #000;
            padding: 40px;
            border-radius: 0px;
            text-align: center;
            border: 2px solid #fff;
            min-width: 300px;
        }

        button {
            background: #222;
            color: white;
            border: 1px solid #fff;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 0px;
            cursor: pointer;
            font-size: 16px;
            width: 200px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        button.primary { background: #fff; color: #000; font-weight: bold; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="settings-btn" class="hidden">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.81,11.69,4.81,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.5c-1.93,0-3.5-1.57-3.5-3.5 s1.57-3.5,3.5-3.5s3.5,1.57,3.5,3.5S13.93,15.5,12,15.5z"/></svg>
    </div>

    <div id="crosshair" class="hidden"></div>

    <div id="left-joystick" class="joystick-container"><div class="joystick-knob"></div></div>
    <div id="jump-btn">Pular</div>
    <div id="right-joystick" class="joystick-container"><div class="joystick-knob"></div></div>

    <div id="main-menu" class="overlay">
        <div class="menu-card">
            <h1>NOIR ESCAPE</h1>
            <p>A realidade perdeu o seu tom.</p>
            <p>Encontre a luz na escuridão.</p>
            <button class="primary" onclick="startGame()">Iniciar</button>
        </div>
    </div>

    <div id="options-menu" class="overlay hidden">
        <div class="menu-card">
            <h2>Pausa</h2>
            <button class="primary" onclick="resumeGame()">Continuar</button>
            <button onclick="exitToMenu()">Sair</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        let scene, camera, renderer, world;
        let playerBody, boxBody, boxMesh;
        let input = { forward: 0, backward: 0, left: 0, right: 0 };
        let isHoldingBox = false;
        let gameRunning = false;
        let pitch = 0, yaw = 0;
        
        let joysticks = {
            left: { active: false, identifier: null, startX: 0, startY: 0, moveX: 0, moveY: 0 },
            right: { active: false, identifier: null, startX: 0, startY: 0, moveX: 0, moveY: 0 }
        };

        const mainMenu = document.getElementById('main-menu');
        const optionsMenu = document.getElementById('options-menu');
        const settingsBtn = document.getElementById('settings-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const uiLeftJoy = document.getElementById('left-joystick');
        const uiRightJoy = document.getElementById('right-joystick');
        const crosshair = document.getElementById('crosshair');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.05);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            world = new CANNON.World();
            world.gravity.set(0, -25, 0); 
            world.defaultContactMaterial.friction = 0.5;
            world.defaultContactMaterial.restitution = 0.1;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            // Luz principal - agora branca fria
            const roomLight = new THREE.PointLight(0xffffff, 1.5, 40);
            roomLight.position.set(0, 8, -5);
            roomLight.castShadow = true;
            scene.add(roomLight);

            // Luz de saída
            const exitLight = new THREE.PointLight(0xffffff, 2.0, 30);
            exitLight.position.set(0, 7, 25);
            scene.add(exitLight);

            // MATERIAIS PRETO E BRANCO
            const floorMat = 0x222222;
            const wallMat = 0x666666;
            const corridorMat = 0x0a0a0a;
            const doorW = 4, doorH = 6, doorZ = 10, corrL = 20;

            // SALA PRINCIPAL
            createWall(20, 1, 20, 0, -0.5, 0, floorMat);  
            createWall(20, 1, 20, 0, 12, 0, wallMat);   
            createWall(20, 12, 1, 0, 6, -10, wallMat);  
            createWall(1, 12, 20, -10, 6, 0, wallMat);  
            createWall(1, 12, 20, 10, 6, 0, wallMat);   
            
            const thresholdHeight = 5.5; 
            const sideW = (20 - doorW) / 2;
            
            createWall(doorW, thresholdHeight, 1, 0, thresholdHeight / 2, doorZ, wallMat); 
            createWall(sideW, 12, 1, -10 + sideW/2, 6, doorZ, wallMat);
            createWall(sideW, 12, 1, 10 - sideW/2, 6, doorZ, wallMat);
            
            const topWallHeight = 12 - (thresholdHeight + doorH);
            if(topWallHeight > 0) {
                createWall(doorW, topWallHeight, 1, 0, 12 - topWallHeight/2, doorZ, wallMat);
            }

            // CORREDOR
            const cZ = doorZ + corrL / 2;
            const floorLevel = thresholdHeight;
            createWall(1, doorH + 2, corrL, -doorW/2 - 0.5, floorLevel + doorH/2, cZ, corridorMat); 
            createWall(1, doorH + 2, corrL, doorW/2 + 0.5, floorLevel + doorH/2, cZ, corridorMat);  
            createWall(doorW + 2, 1, corrL, 0, floorLevel + doorH, cZ, corridorMat); 
            createWall(doorW + 2, 1, corrL, 0, floorLevel, cZ, corridorMat); 
            
            const lightWall = new THREE.Mesh(
                new THREE.BoxGeometry(doorW, doorH, 0.5),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            lightWall.position.set(0, floorLevel + doorH/2, doorZ + corrL);
            scene.add(lightWall);

            // JOGADOR
            const playerShape = new CANNON.Sphere(0.6);
            playerBody = new CANNON.Body({ mass: 1 });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, 2, -5);
            playerBody.fixedRotation = true;
            playerBody.linearDamping = 0.9; 
            world.addBody(playerBody);

            // OBJETO (CAIXA) - BRANCO PARA DESTACAR
            const bS = 1.5;
            const boxShape = new CANNON.Box(new CANNON.Vec3(bS/2, bS/2, bS/2));
            boxBody = new CANNON.Body({ mass: 5 });
            boxBody.addShape(boxShape);
            boxBody.position.set(4, 2, -2);
            world.addBody(boxBody);

            boxMesh = new THREE.Mesh(
                new THREE.BoxGeometry(bS, bS, bS),
                new THREE.MeshPhongMaterial({ color: 0xcccccc })
            );
            boxMesh.castShadow = true;
            scene.add(boxMesh);

            window.addEventListener('resize', onWindowResize);
            
            window.addEventListener('keydown', (e) => updateKeyboard(e.code, 1));
            window.addEventListener('keyup', (e) => updateKeyboard(e.code, 0));
            
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mousedown', (e) => {
                if(gameRunning && e.button === 0) interact();
            });

            window.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            jumpBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                tryJump();
            });

            settingsBtn.addEventListener('click', openOptions);

            animate();
        }

        function createWall(w, h, d, x, y, z, color) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color }));
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({ mass: 0 }); 
            body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
            body.position.set(x, y, z);
            world.addBody(body);
        }

        function startGame() {
            mainMenu.classList.add('hidden');
            settingsBtn.classList.remove('hidden');
            crosshair.classList.remove('hidden');
            uiLeftJoy.style.display = 'block';
            uiRightJoy.style.display = 'block';
            jumpBtn.style.display = 'flex';
            gameRunning = true;
            if (!/Mobi|Android/i.test(navigator.userAgent)) {
                renderer.domElement.requestPointerLock();
            }
        }

        function resumeGame() {
            optionsMenu.classList.add('hidden');
            gameRunning = true;
            if (!/Mobi|Android/i.test(navigator.userAgent)) {
                renderer.domElement.requestPointerLock();
            }
        }

        function openOptions() {
            gameRunning = false;
            optionsMenu.classList.remove('hidden');
            document.exitPointerLock();
        }

        function exitToMenu() {
            location.reload();
        }

        function tryJump() {
            if (!gameRunning) return;
            if (Math.abs(playerBody.velocity.y) < 0.5) {
                playerBody.velocity.y = 9.8; 
            }
        }

        function handleMouseMove(e) {
            if (!gameRunning) return;
            if (document.pointerLockElement === renderer.domElement) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-1.5, Math.min(1.5, pitch));
            }
        }

        function handleTouchStart(e) {
            if (!gameRunning) return;
            for (let t of e.changedTouches) {
                if (t.clientX < window.innerWidth / 3) {
                    joysticks.left.active = true;
                    joysticks.left.identifier = t.identifier;
                    joysticks.left.startX = t.clientX;
                    joysticks.left.startY = t.clientY;
                } else if (t.clientX > window.innerWidth * 2/3) {
                    joysticks.right.active = true;
                    joysticks.right.identifier = t.identifier;
                    joysticks.right.startX = t.clientX;
                    joysticks.right.startY = t.clientY;
                } else if (t.target.id !== 'jump-btn' && t.target.id !== 'settings-btn') {
                    interact();
                }
            }
        }

        function handleTouchMove(e) {
            if (!gameRunning) return;
            for (let t of e.changedTouches) {
                if (joysticks.left.active && t.identifier === joysticks.left.identifier) {
                    joysticks.left.moveX = (t.clientX - joysticks.left.startX) / 40;
                    joysticks.left.moveY = (t.clientY - joysticks.left.startY) / 40;
                    updateJoyUI(uiLeftJoy, joysticks.left.moveX, joysticks.left.moveY);
                }
                if (joysticks.right.active && t.identifier === joysticks.right.identifier) {
                    const dx = (t.clientX - joysticks.right.startX) * 0.006;
                    const dy = (t.clientY - joysticks.right.startY) * 0.006;
                    yaw -= dx;
                    pitch -= dy;
                    pitch = Math.max(-1.5, Math.min(1.5, pitch));
                    joysticks.right.startX = t.clientX;
                    joysticks.right.startY = t.clientY;
                    updateJoyUI(uiRightJoy, dx*10, dy*10);
                }
            }
        }

        function handleTouchEnd(e) {
            for (let t of e.changedTouches) {
                if (t.identifier === joysticks.left.identifier) {
                    joysticks.left.active = false;
                    joysticks.left.moveX = 0; joysticks.left.moveY = 0;
                    updateJoyUI(uiLeftJoy, 0, 0);
                }
                if (t.identifier === joysticks.right.identifier) {
                    joysticks.right.active = false;
                    updateJoyUI(uiRightJoy, 0, 0);
                }
            }
        }

        function updateJoyUI(el, x, y) {
            const knob = el.querySelector('.joystick-knob');
            const limit = 40;
            const mag = Math.sqrt(x*x + y*y);
            let tx = x * 15, ty = y * 15;
            if (mag > 2) { 
                const angle = Math.atan2(y, x);
                tx = Math.cos(angle) * limit; ty = Math.sin(angle) * limit;
            }
            knob.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
        }

        function interact() {
            const mouse = new THREE.Vector2(0, 0); 
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(boxMesh);

            if (isHoldingBox) {
                isHoldingBox = false;
                boxBody.mass = 5;
                boxBody.updateMassProperties();
            } else if (intersects.length > 0 && intersects[0].distance < 6) {
                isHoldingBox = true;
                boxBody.mass = 0; 
                boxBody.velocity.set(0,0,0);
                boxBody.angularVelocity.set(0,0,0);
                boxBody.updateMassProperties();
            }
        }

        function updateKeyboard(code, val) {
            if (!gameRunning) return;
            switch(code) {
                case 'KeyW': input.forward = val; break;
                case 'KeyS': input.backward = val; break;
                case 'KeyA': input.left = val; break;
                case 'KeyD': input.right = val; break;
                case 'Space': if(val) tryJump(); break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameRunning) {
                world.step(1/60);

                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                
                let moveZ = (input.forward ? -1 : 0) + (input.backward ? 1 : 0) + joysticks.left.moveY;
                let moveX = (input.left ? -1 : 0) + (input.right ? 1 : 0) + joysticks.left.moveX;
                
                let dir = new THREE.Vector3(moveX, 0, moveZ);
                if (dir.length() > 0.1) {
                    if (dir.length() > 1) dir.normalize();
                    dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    playerBody.velocity.x = dir.x * 7;
                    playerBody.velocity.z = dir.z * 7;
                } else {
                    playerBody.velocity.x *= 0.8;
                    playerBody.velocity.z *= 0.8;
                }

                camera.position.set(playerBody.position.x, playerBody.position.y + 0.6, playerBody.position.z);

                if (isHoldingBox) {
                    const target = new THREE.Vector3(0, 0, -3.5).applyQuaternion(camera.quaternion).add(camera.position);
                    boxBody.position.lerp(new CANNON.Vec3(target.x, target.y, target.z), 0.2, boxBody.position);
                    boxBody.velocity.set(0,0,0); 
                }

                if (playerBody.position.z > 24 && playerBody.position.y > 5) {
                    gameRunning = false;
                    const winOverlay = document.createElement('div');
                    winOverlay.className = 'overlay';
                    winOverlay.innerHTML = '<div class="menu-card"><h1>LIBERDADE</h1><p>A cor retornará... um dia.</p><button class="primary" onclick="location.reload()">Recomeçar</button></div>';
                    document.body.appendChild(winOverlay);
                }
            }

            boxMesh.position.copy(boxBody.position);
            boxMesh.quaternion.copy(boxBody.quaternion);
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
