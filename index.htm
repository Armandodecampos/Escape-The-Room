<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Escape Room 3D - Noir Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; touch-action: none; }
        canvas { display: block; filter: grayscale(100%) contrast(120%); }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            border: 1px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .joystick-container {
            position: absolute;
            bottom: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            z-index: 150;
            display: none;
            touch-action: none;
        }
        #left-joystick { left: 40px; }
        #right-joystick { right: 40px; }
        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #jump-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 160;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            user-select: none;
        }

        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            text-align: center;
            cursor: pointer;
            z-index: 100;
            color: white;
            opacity: 0.7;
        }
        #settings-btn svg {
            width: 40px;
            height: 40px;
            fill: white;
            display: block;
            margin: 0 auto;
        }
        #settings-btn span {
            font-size: 12px;
            font-weight: bold;
            display: block;
            margin-top: -5px;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 200;
        }

        .menu-card {
            background: #000; padding: 40px; text-align: center;
            border: 2px solid #fff; min-width: 300px;
        }

        button {
            background: #222; color: white; border: 1px solid #fff;
            padding: 12px 24px; margin: 10px; border-radius: 0;
            cursor: pointer; font-size: 16px; width: 200px;
            text-transform: uppercase; letter-spacing: 2px;
        }
        button.primary { background: #fff; color: #000; font-weight: bold; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="settings-btn" class="hidden">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.81,11.69,4.81,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.5c-1.93,0-3.5-1.57-3.5-3.5 s1.57-3.5,3.5-3.5s3.5,1.57,3.5,3.5S13.93,15.5,12,15.5z"/></svg>
        <span>ESC</span>
    </div>

    <div id="crosshair" class="hidden"></div>
    <div id="left-joystick" class="joystick-container"><div class="joystick-knob"></div></div>
    <div id="jump-btn">Pular</div>
    <div id="right-joystick" class="joystick-container"><div class="joystick-knob"></div></div>

    <div id="main-menu" class="overlay">
        <div class="menu-card">
            <h1>NOIR ESCAPE</h1>
            <p>Empilhe a caixa para alcançar a saída.</p>
            <p>Pule enquanto está sobre a caixa.</p>
            <button class="primary" onclick="startGame()">Começar</button>
        </div>
    </div>

    <div id="options-menu" class="overlay hidden">
        <div class="menu-card">
            <h2>Pausa</h2>
            <button class="primary" onclick="resumeGame()">Voltar</button>
            <button onclick="toggleMobileControls(event)">Controles Mobile: ON</button>
            <button onclick="exitToMenu()">Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        let scene, camera, renderer, world;
        let playerBody, boxBody, boxMesh;
        let input = { forward: 0, backward: 0, left: 0, right: 0 };
        let isHoldingBox = false;
        let gameRunning = false;
        let showMobileControls = true;
        let pitch = 0, yaw = 0;
        
        let joysticks = {
            left: { active: false, identifier: null, startX: 0, startY: 0, moveX: 0, moveY: 0 },
            right: { active: false, identifier: null, startX: 0, startY: 0, moveX: 0, moveY: 0 }
        };

        const mainMenu = document.getElementById('main-menu');
        const optionsMenu = document.getElementById('options-menu');
        const settingsBtn = document.getElementById('settings-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const uiLeftJoy = document.getElementById('left-joystick');
        const uiRightJoy = document.getElementById('right-joystick');
        const crosshair = document.getElementById('crosshair');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.04);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            world = new CANNON.World();
            world.gravity.set(0, -28, 0); // Gravidade ligeiramente maior para evitar flutuação

            // Materiais de Física para Fricção Elevada
            const groundMaterial = new CANNON.Material("groundMaterial");
            const boxMaterial = new CANNON.Material("boxMaterial");
            const playerMaterial = new CANNON.Material("playerMaterial");
            
            const contactMaterial = new CANNON.ContactMaterial(groundMaterial, boxMaterial, { friction: 0.9, restitution: 0.1 });
            const playerBoxMaterial = new CANNON.ContactMaterial(playerMaterial, boxMaterial, { friction: 1.0, restitution: 0.0 });
            world.addContactMaterial(contactMaterial);
            world.addContactMaterial(playerBoxMaterial);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            const roomLight = new THREE.PointLight(0xffffff, 1.5, 50);
            roomLight.position.set(0, 10, -5);
            roomLight.castShadow = true;
            scene.add(roomLight);

            const exitLight = new THREE.PointLight(0xffffff, 2.5, 40);
            exitLight.position.set(0, 10, 25);
            scene.add(exitLight);

            // DIMENSÕES E MATERIAIS
            const doorW = 4, doorH = 6, doorZ = 10, corrL = 20;
            const thresholdHeight = 4.2; // EXIGE A CAIXA PARA SAIR

            // CONSTRUÇÃO
            createWall(20, 1, 20, 0, -0.5, 0, 0x111111, groundMaterial);  // Chão
            createWall(20, 12, 1, 0, 6, -10, 0x555555, groundMaterial); // Fundo
            createWall(1, 12, 20, -10, 6, 0, 0x555555, groundMaterial); // Esq
            createWall(1, 12, 20, 10, 6, 0, 0x555555, groundMaterial);  // Dir
            
            // Parede da frente com porta elevada
            const sideW = (20 - doorW) / 2;
            createWall(doorW, thresholdHeight, 1, 0, thresholdHeight / 2, doorZ, 0x555555, groundMaterial); 
            createWall(sideW, 12, 1, -10 + sideW/2, 6, doorZ, 0x555555, groundMaterial);
            createWall(sideW, 12, 1, 10 - sideW/2, 6, doorZ, 0x555555, groundMaterial);
            createWall(doorW, 12 - (thresholdHeight + doorH), 1, 0, 12 - (12 - thresholdHeight - doorH)/2, doorZ, 0x555555, groundMaterial);

            // Corredor de Saída
            const cZ = doorZ + corrL / 2;
            createWall(doorW + 2, 1, corrL, 0, thresholdHeight, cZ, 0x050505, groundMaterial); // Chão corredor
            createWall(1, doorH + 2, corrL, -doorW/2 - 0.5, thresholdHeight + doorH/2, cZ, 0x050505, groundMaterial); 
            createWall(1, doorH + 2, corrL, doorW/2 + 0.5, thresholdHeight + doorH/2, cZ, 0x050505, groundMaterial);  

            // JOGADOR
            const playerShape = new CANNON.Sphere(0.7);
            playerBody = new CANNON.Body({ mass: 80, material: playerMaterial });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, 2, -5);
            playerBody.fixedRotation = true;
            playerBody.linearDamping = 0.95;
            world.addBody(playerBody);

            // CAIXA
            const bS = 1.8; // Aumentei ligeiramente o tamanho da caixa
            const boxShape = new CANNON.Box(new CANNON.Vec3(bS/2, bS/2, bS/2));
            boxBody = new CANNON.Body({ mass: 50, material: boxMaterial });
            boxBody.addShape(boxShape);
            boxBody.position.set(5, 2, -3);
            world.addBody(boxBody);

            boxMesh = new THREE.Mesh(
                new THREE.BoxGeometry(bS, bS, bS),
                new THREE.MeshPhongMaterial({ color: 0xeeeeee })
            );
            boxMesh.castShadow = true;
            scene.add(boxMesh);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => updateKeyboard(e.code, 1));
            window.addEventListener('keyup', (e) => updateKeyboard(e.code, 0));
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mousedown', (e) => { if(gameRunning && e.button === 0) interact(); });
            window.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd, { passive: false });
            jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); tryJump(); });
            settingsBtn.addEventListener('touchstart', (e) => { e.preventDefault(); openOptions(); });
            renderer.domElement.addEventListener('click', () => {
                if (gameRunning && !/Mobi|Android/i.test(navigator.userAgent)) {
                    renderer.domElement.requestPointerLock();
                }
            });
            window.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement !== renderer.domElement && gameRunning && !/Mobi|Android/i.test(navigator.userAgent)) {
                    // Optional: could auto-pause here, but for now we just allow re-locking on click
                }
            });
            animate();
        }

        function createWall(w, h, d, x, y, z, color, mat) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color }));
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, material: mat }); 
            body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
            body.position.set(x, y, z);
            world.addBody(body);
        }

        function startGame() {
            mainMenu.classList.add('hidden');
            settingsBtn.classList.remove('hidden');
            crosshair.classList.remove('hidden');
            uiLeftJoy.style.display = 'block';
            uiRightJoy.style.display = 'block';
            jumpBtn.style.display = 'flex';
            gameRunning = true;
            if (!/Mobi|Android/i.test(navigator.userAgent)) renderer.domElement.requestPointerLock();
        }

        function resumeGame() {
            optionsMenu.classList.add('hidden');
            gameRunning = true;
        }

        function toggleMobileControls(e) {
            showMobileControls = !showMobileControls;
            const state = showMobileControls ? "ON" : "OFF";
            const btn = e || window.event;
            const target = btn.target || btn.srcElement;
            target.innerText = "Controles Mobile: " + state;

            const display = showMobileControls ? "block" : "none";
            const flexDisplay = showMobileControls ? "flex" : "none";

            uiLeftJoy.style.display = display;
            uiRightJoy.style.display = display;
            jumpBtn.style.display = flexDisplay;
        }

        function openOptions() {
            gameRunning = false;
            optionsMenu.classList.remove('hidden');
            document.exitPointerLock();
        }

        function exitToMenu() { location.reload(); }

        function tryJump() {
            if (!gameRunning) return;
            // Detecção de chão melhorada: verifica velocidade vertical quase nula
            if (Math.abs(playerBody.velocity.y) < 0.8) {
                playerBody.velocity.y = 18; // Ajustado para 15
            }
        }

        function handleMouseMove(e) {
            if (!gameRunning || document.pointerLockElement !== renderer.domElement) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
        }

        function handleTouchStart(e) {
            if (!gameRunning) return;
            for (let t of e.changedTouches) {
                if (t.clientX < window.innerWidth / 3) {
                    joysticks.left.active = true;
                    joysticks.left.identifier = t.identifier;
                    joysticks.left.startX = t.clientX;
                    joysticks.left.startY = t.clientY;
                } else if (t.clientX > window.innerWidth * 2/3) {
                    joysticks.right.active = true;
                    joysticks.right.identifier = t.identifier;
                    joysticks.right.startX = t.clientX;
                    joysticks.right.startY = t.clientY;
                } else {
                    if (t.target.id !== 'jump-btn' && t.target.id !== 'settings-btn') interact();
                }
            }
        }

        function handleTouchMove(e) {
            if (!gameRunning) return;
            for (let t of e.changedTouches) {
                if (joysticks.left.active && t.identifier === joysticks.left.identifier) {
                    joysticks.left.moveX = (t.clientX - joysticks.left.startX) / 40;
                    joysticks.left.moveY = (t.clientY - joysticks.left.startY) / 40;
                    updateJoyUI(uiLeftJoy, joysticks.left.moveX, joysticks.left.moveY);
                }
                if (joysticks.right.active && t.identifier === joysticks.right.identifier) {
                    const dx = (t.clientX - joysticks.right.startX) * 0.005;
                    const dy = (t.clientY - joysticks.right.startY) * 0.005;
                    yaw -= dx;
                    pitch -= dy;
                    pitch = Math.max(-1.5, Math.min(1.5, pitch));
                    joysticks.right.startX = t.clientX;
                    joysticks.right.startY = t.clientY;
                    updateJoyUI(uiRightJoy, dx*10, dy*10);
                }
            }
        }

        function handleTouchEnd(e) {
            for (let t of e.changedTouches) {
                if (t.identifier === joysticks.left.identifier) {
                    joysticks.left.active = false; joysticks.left.moveX = 0; joysticks.left.moveY = 0;
                    updateJoyUI(uiLeftJoy, 0, 0);
                }
                if (t.identifier === joysticks.right.identifier) {
                    joysticks.right.active = false;
                    updateJoyUI(uiRightJoy, 0, 0);
                }
            }
        }

        function updateJoyUI(el, x, y) {
            const knob = el.querySelector('.joystick-knob');
            const limit = 40;
            const mag = Math.sqrt(x*x + y*y);
            let tx = x * 15, ty = y * 15;
            if (mag > 2) { 
                const angle = Math.atan2(y, x);
                tx = Math.cos(angle) * limit; ty = Math.sin(angle) * limit;
            }
            knob.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
        }

        function interact() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObject(boxMesh);

            if (isHoldingBox) {
                isHoldingBox = false;
            } else if (intersects.length > 0 && intersects[0].distance < 7) {
                isHoldingBox = true;
            }
        }

        function updateKeyboard(code, val) {
            if (!gameRunning) return;
            switch(code) {
                case 'KeyW': input.forward = val; break;
                case 'KeyS': input.backward = val; break;
                case 'KeyA': input.left = val; break;
                case 'KeyD': input.right = val; break;
                case 'Space': if(val) tryJump(); break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameRunning) {
                world.step(1/60);
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                
                let moveZ = (input.forward ? -1 : 0) + (input.backward ? 1 : 0) + joysticks.left.moveY;
                let moveX = (input.left ? -1 : 0) + (input.right ? 1 : 0) + joysticks.left.moveX;
                let dir = new THREE.Vector3(moveX, 0, moveZ);
                if (dir.length() > 0.1) {
                    if (dir.length() > 1) dir.normalize();
                    dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    playerBody.velocity.x = dir.x * 8;
                    playerBody.velocity.z = dir.z * 8;
                } else if (Math.abs(playerBody.velocity.y) < 0.8) {
                    playerBody.velocity.x = 0;
                    playerBody.velocity.z = 0;
                }
                camera.position.set(playerBody.position.x, playerBody.position.y + 0.7, playerBody.position.z);

                if (isHoldingBox) {
                    const target = new THREE.Vector3(0, -0.5, -4).applyQuaternion(camera.quaternion).add(camera.position);
                    boxBody.velocity.set(
                        (target.x - boxBody.position.x) * 10,
                        (target.y - boxBody.position.y) * 10,
                        (target.z - boxBody.position.z) * 10
                    );
                    boxBody.angularVelocity.set(0, 0, 0);
                }

                if (playerBody.position.z > 24 && playerBody.position.y > 4) {
                    gameRunning = false;
                    const winOverlay = document.createElement('div');
                    winOverlay.className = 'overlay';
                    winOverlay.innerHTML = '<div class="menu-card"><h1>LIBERDADE</h1><button class="primary" onclick="location.reload()">NOVA TENTATIVA</button></div>';
                    document.body.appendChild(winOverlay);
                }
            }
            boxMesh.position.copy(boxBody.position);
            boxMesh.quaternion.copy(boxBody.quaternion);
            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>
