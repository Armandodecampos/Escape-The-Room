<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Room 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
        canvas { display: block; }

        /* Interface Principal */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        /* Botão de Engrenagem */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 100;
            fill: white;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #settings-btn:hover { opacity: 1; }

        /* Telas de Menu */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
        }

        .menu-card {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #333;
            min-width: 300px;
        }

        button {
            background: #444;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            width: 200px;
            transition: background 0.2s;
        }
        button:hover { background: #666; }
        button.primary { background: #e67e22; }
        button.primary:hover { background: #d35400; }

        .hidden { display: none !important; }

        #controls-info {
            font-size: 14px;
            color: #aaa;
            margin-top: 20px;
            text-align: left;
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <!-- Ícone de Engrenagem -->
    <div id="settings-btn" class="hidden">
        <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.81,11.69,4.81,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.5c-1.93,0-3.5-1.57-3.5-3.5 s1.57-3.5,3.5-3.5s3.5,1.57,3.5,3.5S13.93,15.5,12,15.5z"/></svg>
    </div>

    <div id="crosshair" class="hidden"></div>

    <div id="main-menu" class="overlay">
        <div class="menu-card">
            <h1>ESCAPE ROOM</h1>
            <p>Consegues sair da sala?</p>
            <button class="primary" onclick="startGame()">Iniciar Jogo</button>
        </div>
    </div>

    <div id="options-menu" class="overlay hidden">
        <div class="menu-card">
            <h2>Opções</h2>
            <button onclick="toggleControls()">Controles</button>
            <button onclick="exitToMenu()">Sair</button>
            <button class="primary" onclick="resumeGame()">Voltar ao Jogo</button>
            
            <div id="controls-panel" class="hidden">
                <div id="controls-info">
                    <strong>Movimento:</strong> W, A, S, D<br>
                    <strong>Saltar:</strong> Espaço<br>
                    <strong>Interagir:</strong> Clique no Rato<br>
                    <strong>Olhar:</strong> Movimento do Rato
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        let scene, camera, renderer, world;
        let playerBody, boxBody, boxMesh;
        let input = { forward: false, backward: false, left: false, right: false, jump: false };
        let isGrounded = false;
        let isHoldingBox = false;
        let gameRunning = false;
        let pitch = 0, yaw = 0;
        const clock = new THREE.Clock();

        const mainMenu = document.getElementById('main-menu');
        const optionsMenu = document.getElementById('options-menu');
        const settingsBtn = document.getElementById('settings-btn');
        const crosshair = document.getElementById('crosshair');
        const controlsPanel = document.getElementById('controls-panel');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            // Luz da sala principal
            const roomLight = new THREE.PointLight(0xffaa44, 1.5, 25);
            roomLight.position.set(0, 8, -5);
            roomLight.castShadow = true;
            scene.add(roomLight);

            // Luz no fim do corredor (mais intensa)
            const exitLight = new THREE.PointLight(0xffffff, 2.5, 20);
            exitLight.position.set(0, 7, 25);
            scene.add(exitLight);

            world = new CANNON.World();
            world.gravity.set(0, -18, 0);

            // CONFIGURAÇÕES VISUAIS
            const orangeMat = 0xcc6600; // Cor Laranja da Sala
            const corridorMat = 0x111111; // Cor Escura do Corredor
            const doorWidth = 4;
            const doorHeight = 6;
            const doorZ = 10;
            const corridorLength = 15;

            // CHÃO E TETO DA SALA
            createWall(20, 1, 20, 0, -0.5, 0, orangeMat); 
            createWall(20, 1, 20, 0, 12, 0, orangeMat);

            // PAREDES DA SALA (Laranja)
            createWall(20, 12, 1, 0, 6, -10, orangeMat); // Fundo
            createWall(1, 12, 20, -10, 6, 0, orangeMat); // Esquerda
            createWall(1, 12, 20, 10, 6, 0, orangeMat);  // Direita
            
            // PAREDE FRONTAL COM PORTA (Laranja)
            const sideWallWidth = (20 - doorWidth) / 2;
            createWall(20, 4.5, 1, 0, 2.25, doorZ, orangeMat); // Base (obstáculo)
            createWall(sideWallWidth, 7.5, 1, -10 + sideWallWidth/2, 8.25, doorZ, orangeMat); // Lateral Esq
            createWall(sideWallWidth, 7.5, 1, 10 - sideWallWidth/2, 8.25, doorZ, orangeMat);  // Lateral Dir
            createWall(doorWidth, 1.5, 1, 0, 11.25, doorZ, orangeMat); // Umbral superior

            // CORREDOR SIMPLIFICADO (Mesma largura da porta)
            const corridorZPos = doorZ + corridorLength / 2;
            createWall(1, doorHeight + 1.5, corridorLength, -doorWidth/2 - 0.5, doorHeight/2 + 4.5, corridorZPos, corridorMat); // Parede Esq
            createWall(1, doorHeight + 1.5, corridorLength, doorWidth/2 + 0.5, doorHeight/2 + 4.5, corridorZPos, corridorMat);  // Parede Dir
            createWall(doorWidth + 2, 1, corridorLength, 0, 12, corridorZPos, corridorMat); // Teto Corredor
            createWall(doorWidth + 2, 1, corridorLength, 0, 4, corridorZPos, corridorMat);  // Piso Corredor (continuação do umbral)
            
            // PAREDE DE LUZ AO FUNDO
            const lightWall = new THREE.Mesh(
                new THREE.BoxGeometry(doorWidth, doorHeight + 2, 0.5),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            lightWall.position.set(0, 8, doorZ + corridorLength);
            scene.add(lightWall);

            // JOGADOR
            const playerShape = new CANNON.Sphere(0.5);
            playerBody = new CANNON.Body({ mass: 1 });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, 2, -5);
            playerBody.fixedRotation = true;
            world.addBody(playerBody);

            // CAIXA
            const boxSize = 1.2;
            const boxShape = new CANNON.Box(new CANNON.Vec3(boxSize/2, boxSize/2, boxSize/2));
            boxBody = new CANNON.Body({ mass: 5 });
            boxBody.addShape(boxShape);
            boxBody.position.set(4, 1, -2);
            world.addBody(boxBody);

            boxMesh = new THREE.Mesh(
                new THREE.BoxGeometry(boxSize, boxSize, boxSize),
                new THREE.MeshPhongMaterial({ color: 0x552200 })
            );
            boxMesh.castShadow = true;
            scene.add(boxMesh);

            // Eventos
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => updateInput(e.code, true));
            document.addEventListener('keyup', (e) => updateInput(e.code, false));
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            settingsBtn.addEventListener('click', openOptions);

            animate();
        }

        function createWall(w, h, d, x, y, z, color) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshPhongMaterial({ color }));
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            scene.add(mesh);

            const body = new CANNON.Body({ mass: 0 });
            body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
            body.position.set(x, y, z);
            world.addBody(body);
        }

        function startGame() {
            mainMenu.classList.add('hidden');
            settingsBtn.classList.remove('hidden');
            crosshair.classList.remove('hidden');
            document.body.requestPointerLock();
            gameRunning = true;
        }

        function openOptions() {
            gameRunning = false;
            document.exitPointerLock();
            optionsMenu.classList.remove('hidden');
            controlsPanel.classList.add('hidden');
        }

        function resumeGame() {
            optionsMenu.classList.add('hidden');
            document.body.requestPointerLock();
            gameRunning = true;
        }

        function exitToMenu() {
            optionsMenu.classList.add('hidden');
            settingsBtn.classList.add('hidden');
            crosshair.classList.add('hidden');
            mainMenu.classList.remove('hidden');
            gameRunning = false;
            playerBody.position.set(0, 2, -5);
            playerBody.velocity.set(0,0,0);
        }

        function toggleControls() {
            controlsPanel.classList.toggle('hidden');
        }

        function onMouseDown() {
            if (!gameRunning || !document.pointerLockElement) return;

            if (isHoldingBox) {
                isHoldingBox = false;
                boxBody.mass = 5;
                boxBody.updateMassProperties();
            } else {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromComponents(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObject(boxMesh);
                if (intersects.length > 0 && intersects[0].distance < 4) {
                    isHoldingBox = true;
                    boxBody.mass = 0;
                    boxBody.updateMassProperties();
                }
            }
        }

        function onMouseMove(e) {
            if (gameRunning && document.pointerLockElement) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
            }
        }

        function updateInput(code, state) {
            if (!gameRunning) return;
            switch(code) {
                case 'KeyW': input.forward = state; break;
                case 'KeyS': input.backward = state; break;
                case 'KeyA': input.left = state; break;
                case 'KeyD': input.right = state; break;
                case 'Space': if(state && isGrounded) input.jump = true; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameRunning) {
                world.step(1/60);

                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                const speed = 6;
                let moveZ = (input.forward ? -1 : 0) + (input.backward ? 1 : 0);
                let moveX = (input.left ? -1 : 0) + (input.right ? 1 : 0);
                
                let dir = new THREE.Vector3(moveX, 0, moveZ).normalize();
                dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                playerBody.velocity.x = dir.x * speed;
                playerBody.velocity.z = dir.z * speed;

                if (input.jump) {
                    playerBody.velocity.y = 9;
                    input.jump = false;
                    isGrounded = false;
                }

                camera.position.set(playerBody.position.x, playerBody.position.y + 0.6, playerBody.position.z);
                if (Math.abs(playerBody.velocity.y) < 0.1) isGrounded = true;

                if (isHoldingBox) {
                    const target = new THREE.Vector3(0, 0, -2.5).applyQuaternion(camera.quaternion).add(camera.position);
                    boxBody.position.copy(target);
                }

                // Condição de vitória ao chegar ao final do corredor luminoso
                if (playerBody.position.z > 24) {
                    gameRunning = false;
                    alert("Nível 1 Concluído!");
                    exitToMenu();
                }
            }

            boxMesh.position.copy(boxBody.position);
            boxMesh.quaternion.copy(boxBody.quaternion);

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>